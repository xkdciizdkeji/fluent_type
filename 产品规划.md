我想开发一个最优双拼布局生成器。

话题引入：汉语双拼的方案有很多种，但是它们的键盘布局都未必科学，例如每个手指的击键负载可能面临不均衡的情况，以及有些时候可能会出现大量的需要一个手指连续敲击的情况（这回拖慢输入的速度并打乱输入的节奏感）。所以我的动机是在不改变键盘目前形态（不改变键盘的物理按键布局）的前提下，更改双拼输入法中的韵母映射关系，通过某种算法（下面我会介绍这种算法）得到的布局可以获得良好的输入体验。

文字输入的本质是编码，在我看来，输入分为以下两个阶段的映射：
1. 语言到字母编码映射：对于英语来说，这种映射关系是直接的，比如我要输入apple，那我需要输入的字母编码就是apple。但是对于非英语的语言来说，这种映射关系需要引入一些编码逻辑，例如汉语拼音就是一种字母编码汉字的逻辑，比如我要输入“苹果”，那么我需要输入的字母编码就是“pingguo”；
	1. 再比如一些汉语双拼编码方案例如小鹤双拼，要输入苹果就需要输入的字母编码就是“pkgo”。因为在双拼中，额外添加了一层映射逻辑：韵母到字母的映射，例如在小鹤双拼中，k代表ing，o代表uo，所以，要输入pingguo，只需要输入pkgo就可以达成和全拼一样的效果。
2. 然后是字母到物理按键键位的映射：对于目前来说，使用最广泛的当然就是qwerty键盘布局。我们以英语举例，可能还存在一些其他的键盘布局可以获得更好的输入体验。但是这一层映射我不打算改变，因为绝大多数键盘上印着的字母都是固定位置，如果改变这一层映射逻辑，将会使通用性大大降低。


什么是好的输入体验。在我看来有以下几个标准：
1. 尽可能减少一根手指连续敲击不同按键的情况，这种情况会大大降低打字的节奏感。连续敲击不同按键的情况出现在字内，比如小鹤双拼打“的”字需要敲击“de”，de这两个字母都需要左手中指敲击
2. 每根手指的击键负担需要尽可能均匀。


我来给你说一下我的算法的思路：
1. 获得汉语拼音串。
   1. 如果有现成的最好（但我猜多半没现成的）。如果没有现成的，首先你需要上网找一些汉语语料（这个你在github上肯定能找到），然后你需要将这些汉语预料转化为一串拼音串。“例如，这是你找到的字符串”，然后你需要生成的汉语拼音字符串为：[[["l","i"],["r","u"]],[["zh","e"],["sh","i"],["n","i"],["zh","ao"],["d","ao"],["d","e"],["z","i"],["f","u"],["ch","uan"]]]。我给你说一下转化的逻辑，首先标点符号等作为第一级的分隔（因为敲击标点符号的时候，我们处于敲击文字的“间断”状态），然后将每个汉字的声母部分和韵母部分提取出来加入到list中（这里需要注意，当你处理到单韵母字时，例如“啊”，你需要产生两个"a",即["a","a"],假装它有一个声母a;当你处理到双韵母字时，例如“奥”，你需要产生["a","o"]）。
2. 根据生成的拼音串产生一个概率矩阵，其中横向为“声母”部分，纵向为“韵母”部分，它们的交叉就是这个音节的出现频率。并将这个矩阵进行可视化产生一个图。
3. 现在我们已经有了“声母”到“韵母”的概率矩阵，然后我们需要构造一个loss函数，其输入是两部分：1.概率矩阵; 2.声母和韵母到键盘上26个英文字母键的按键映射。下面我来说一下我们的loss函数需要怎么构造
   1. 首先，你先随机生成两个映射：
      1. 第一个映射是广义声母（也就是我们产生拼音串功能的每个字符产生的拼音的第一部分）到英文字母的映射
         比如你可以生成：
         b:A(这个英文字母你先随机生成)
         p:D(同理你暂且随机生成,并且这个字母可以和其他的重合，例如这里我也同样可以填A)
         m:
         f
         后面还有
      2. 第二个映射是广义韵母（也就是我们产生拼音串功能的每个字符产生的拼音的第二部分）到英文字母的映射
         比如你可以生成：
         a:I(这个英文字母你先随机生成)
         o:E(同理你暂且随机生成,并且这个字母可以和其他的重合，例如这里我也同样可以填A)
         e:
         i
         后面还有
   2. 然后我们定义我们人类在敲击26键键盘的时候每个手指的控制键盘的范围，例如按照标准指法，我们的控制范围是这样的：
      我们将10根手指从左到右分别编号：左手小指为1，左手无名指为2，左手中指为3，左右食指为4，左右拇指为5，右手拇指为6，右手食指为7，右手中指为8，右手无名指为9，右手小指为10
      你需要产生一个英文字母键盘到手指的映射：
      Q:1（因为在标准指法键位中，Q需要左手小指来敲击）
      W:2（因为在标准指法键位中，W需要左手无名指指来敲击）
      E:3（因为在标准指法键位中，E需要左手中指来敲击）
      R:4（因为在标准指法键位中，R需要左手食指来敲击）
      T:4（因为在标准指法键位中，T仍然需要左手食指来敲击）
      Y:6（因为在标准指法键位中，Y需要右手食指来敲击）
      U:6（因为在标准指法键位中，U需要右手食指来敲击）
      一共26个字母按键，请你按照标准的键盘指法进行生成英文字母键盘到手指的映射。
   3. 然后我们需要构造一个loss函数，我的初步构造方法是这样的：
      1. loss分为两部分计算（我们将其命名为cost1，cost2），分别是：
         1. 衡量一根手指连续敲击不同按键的情况，比如如果我们发生了先后敲击QA两个字母按键的情况时，因为Q按键与A按键都是由左手小指也就是上面的编号1的手指敲击的，所以我们就认为是发生了一根手指连续敲击不同按键的情况。然后我们需要给这种情况设置一些cost。我们可以这样计算cost1
            遍历概率矩阵中所有的“广义声母”+“广义韵母”组合以及它们的概率
               例如我们现在遍历到了“zh”+“an”这个组合以及它们的概率Pa
               然后去查找广义声母到英文字母映射表，比如我们查到了“zh”到“V”；再去查找广义韵母到英文字母映射表，比如我们查找到了“an”到“F”
               然后去找找英文字母到手指的映射表，“V:4”，又查到“F:4”，并且F和V并不是同一个按键，那么这种情况就是出现了一根手指连续敲击不同按键的情况。这种情况就造成了一点cost，这个cost=Pa*Weight_unfluent（这个权重值你预先设置为1即可）
               你累加这个小cost就构成了cost1
         2. 衡量8根手指(编号1、2、3、4、7、8、9、10)的击键均匀程度。（你可能好奇为什么只有8根而不是全部的10根，因为两根大拇指在使用键盘的时候是不参与击键的）
            1. 我们可以这样设置计算cost2的方式
               遍历概率矩阵中所有的“广义声母”+“广义韵母”组合以及它们的概率
               还是那个例子，例如我们现在遍历到了“zh”+“an”这个组合以及它们的概率Pa
               然后去查找广义声母到英文字母映射表，比如我们查到了“zh”到“V”；再去查找广义韵母到英文字母映射表，比如我们查找到了“an”到“F”
               然后去找找英文字母到手指的映射表，“V:4”，又查到“F:4”，然后我们将属于手指4的击键负载进行不断累加。再这里，手指4的击键负载+=(Pa+Pa)
               最终，我们将会获得8根手指的击键负载，然后我们为了衡量它们的负载均匀度，我们计算8个数字的方差。
               你累加这个小cost就构成了cost2
         
      显然，越小的loss值代表我们
4. 利用模拟退火算法寻找更优的广义声母到英文字母的映射和广义韵母到英文字母的映射
   1. 我们的模拟退火算法是这样的：
         首先定义随机变换方式，每个iteration，我们随机挑选广义声母和广义韵母中的一种映射进行变动，比方我们随机挑选到一个广义声母，然后我们需要对它的映射进行随机变动。更具体来说，比如我们随机挑中了“g”，然后我们随机再产生一个英文字母映射（比如我们产生了R）
         然后我们我们重新计算loss函数值并且我们将这个新计算出来的loss记为loss_current，将上一个iteration的loss记为loss_last
         接着我们定义一个AP(accept_probability)=exp((loss_current-loss_last)/K)，其中K为温度，温度初始为1，每个iteration都乘以0.99，当K小于0.01的时候，模拟退火过程结束
         对于接不接受一个随机的变动，我们采取以下的标准：
         if(AP>介于[0,1)的真随机数):#需要注意，这个随机数每个iteration都要重新产生，并且一定要保证是真随机数而不是伪随机数。
            则编码映射进行更新
         else:
            不接受这个随机变换的编码映射




